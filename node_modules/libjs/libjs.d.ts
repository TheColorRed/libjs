declare namespace libjs {
    abstract class component {
        protected _elements: HTMLElement[];
        readonly htmlElements: HTMLElement[];
        elements: NodeListOf<HTMLElement>;
        addElement(selector: string): void;
        init(): void;
        initElement(el: HTMLElement): void;
        private initKeyboardEvents(el);
        private initMouseEvents(el);
        private initFormEvents(el);
    }
}
declare namespace libjs {
    function string(str: string | number): strings;
    class strings {
        protected _string: string;
        constructor(str: string | number);
        toString(): string;
        toNumber(): this;
        commaSeparate(): this;
        format(format: string): void;
    }
}
declare namespace libjs {
    interface collectionType<T extends collectionConstructor> {
        new (): T;
    }
    function collect<T>(data: T[]): collection<T>;
    enum pad {
        before = 0,
        after = 1,
    }
    abstract class collectionConstructor {
    }
    class collection<T> extends collectionConstructor implements Iterable<T> {
        private _items;
        private _pointer;
        constructor(data?: any);
        readonly length: number;
        [Symbol.iterator](): {
            next(): IteratorResult<T>;
        };
        index(index: number): T;
        set(items: T[]): this;
        remove(item: T): this;
        each(callback: (item: any, index: number) => any): collection<any>;
        passes(callback: (item: T, index: number) => boolean): boolean;
        fails(callback: (item: T, index: number) => boolean): boolean;
        toArray(): T[];
        append(...vals: T[]): this;
        prepend(...vals: T[]): this;
        first(): T;
        last(): T;
        get(...vals: number[]): collection<T>;
        pad(length: number, value?: any, side?: pad): collection<any>;
        contains(value: any): boolean;
        pluck(key: string): collection<any>;
        unique(): collection<T>;
        take(amount: number): collection<T>;
        skip(amount: number): collection<T>;
        takeWhile(callback: (value, index) => boolean): collection<T>;
        skipWhile(callback: (value, index) => boolean): collection<T>;
        zip(items: collection<any>, callback: (first, second) => any): collection<any>;
        average(key?: string): number;
        min(key?: string): any;
        max(key?: string): number;
    }
}
declare namespace libjs {
    class query<T> {
        private _results;
        private _where;
        constructor(data: any);
        static fromJson(data: string): query<Object>;
        data: any;
        readonly length: number;
        where(key: string, arg1: any, arg2: any, arg3: any): this;
        whereType(key: string, expression: string): this;
        get(): collection<T>;
        private _processWhere();
    }
}
declare namespace libjs {
    interface componentType<T extends component> {
        new (): T;
    }
    function register(comp: componentType<component>): component;
    function domReady(): any;
}
declare namespace libjs {
}
declare var module: any;
