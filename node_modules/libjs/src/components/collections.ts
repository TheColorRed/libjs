namespace libjs {

  export interface collectionType<T extends collectionConstructor> {
    new (): T;
  }

  /**
   * Creates a collection
   *
   * @export
   * @template T
   * @param {any} [data]
   * @returns
   */
  export function collect<T>(data: T[]) {
    return new collection<T>(data)
  }

  /**
   * Pad type
   *
   * @export
   * @enum {number}
   */
  export enum pad { before, after }

  export abstract class collectionConstructor { }

  export class collection<T> extends collectionConstructor implements Iterable<T> {
    private _items: T[] = []
    private _pointer = 0
    public constructor(data?) {
      super()
      if (!data) { return }
      if (Array.isArray(data)) {
        this._items = data
      } else {
        this._items.push(data)
      }
    }

    /**
     * Gets the number of items in the collection
     *
     * @readonly
     * @memberof collection
     */
    public get length() {
      return this._items.length
    }

    /**
     * Iterates over the collection
     *
     * @returns
     * @memberof collection
     */
    public [Symbol.iterator]() {
      let items = this._items
      let pointer = 0
      return {
        next(): IteratorResult<T> {
          if (pointer < items.length) {
            return { done: false, value: items[pointer++] }
          }
          return { done: true, value: items[items.length - 1] }
        }
      }
    }

    /**
     * Get an item at the specified index
     *
     * @param {number} index
     * @returns
     * @memberof collection
     */
    public index(index: number) {
      return this._items[index]
    }

    /**
     * Sets the items in the collection
     *
     * @param {T[]} items
     * @returns
     * @memberof collection
     */
    public set(items: T[]) {
      this._items = items
      return this
    }

    /**
     * Removes an item from the collection
     *
     * @param {T} item
     * @returns
     * @memberof collection
     */
    public remove(item: T) {
      let idx = this._items.indexOf(item)
      if (idx > -1) this._items.splice(idx, 1)
      return this
    }

    /**
     * Applies a callback to each item in the collection
     *
     * @param {(item: any, index: number) => any} callback
     * @returns
     * @memberof collection
     */
    public each(callback: (item: any, index: number) => any) {
      let c = new collection<any>()
      this._items.forEach((i, index) => c.append(callback(i, index)))
      return c
    }

    /**
     * Tests if all items pass a truth test
     *
     * @param {(item: T, index: number) => boolean} callback
     * @returns
     * @memberof collection
     */
    public passes(callback: (item: T, index: number) => boolean) {
      for (let i = 0, l = this.length; i < l; i++) {
        if (!callback(this._items[i], i)) return false
      }
      return true
    }

    /**
     * Tests if all items fail a truth test
     *
     * @param {(item: T, index: number) => boolean} callback
     * @returns
     * @memberof collection
     */
    public fails(callback: (item: T, index: number) => boolean) {
      for (let i = 0, l = this.length; i < l; i++) {
        if (!callback(this._items[i], i)) return true
      }
      return false
    }

    /**
     * Gets the collection as an array
     *
     * @returns
     * @memberof collection
     */
    public toArray() {
      return this._items
    }

    /**
     * Appends one or more items to the end of the colletion
     *
     * @param {...T[]} vals
     * @returns
     * @memberof collection
     */
    public append(...vals: T[]) {
      this._items = this._items.concat(vals)
      return this
    }

    /**
     * Prepends one or more items to the beginning of the collection
     *
     * @param {...T[]} vals
     * @returns
     * @memberof collection
     */
    public prepend(...vals: T[]) {
      this._items = vals.concat(this._items)
      return this
    }

    /**
     * Gets the first item in the collection
     *
     * @returns
     * @memberof collection
     */
    public first() {
      return this._items[0]
    }

    /**
     * Gets the last item in the collection
     *
     * @returns
     * @memberof collection
     */
    public last() {
      return this._items[this.length - 1]
    }

    /**
     * Get all the items in the collection or items at specific keys
     *
     * @param {...number[]} vals
     * @returns
     * @memberof collection
     */
    public get(...vals: number[]) {
      if (vals.length == 0) { return this }
      let r = new collection<T>()
      vals.forEach(i => r.append(this._items[i]))
      return r
    }

    /**
     * Pads the collection either before or after with a specific value if it is shorter than "length".
     *
     * @param {number} length
     * @param {*} [value=null]
     * @param {pad} [side=pad.after]
     * @returns
     * @memberof collection
     */
    public pad(length: number, value: any = null, side: pad = pad.after) {
      let r = new collection<any>()
      r.set(this._items)
      if (r.length >= length) return r
      for (let i = 0, l = length - r.length; i < l; i++) {
        side == pad.after ? r.append(value) : r.prepend(value)
      }
      return r
    }

    /**
     * Tests to see if the collection contains a value
     *
     * @param {*} value
     * @returns {boolean}
     * @memberof collection
     */
    public contains(value: any): boolean {
      for (let i of this._items) {
        if (i == value) return true
      }
      return false
    }

    /**
     * Gets a collection of values based on the key
     *
     * @param {string} key
     * @returns {collection<any>}
     * @memberof collection
     */
    public pluck(key: string): collection<any> {
      let r = new collection<any>()
      this.each(i => i[key] && r.append(i[key]))
      return r
    }

    /**
     * Gets a collection of unique values
     *
     * @returns
     * @memberof collection
     */
    public unique() {
      let r = new collection<T>()
      for (let i of this._items) {
        if (!r.contains(i)) {
          r.append(i)
        }
      }
      return r
    }

    /**
     * Get the first "amount" of items
     *
     * @param {number} amount
     * @returns
     * @memberof collection
     */
    public take(amount: number) {
      let r = new collection<T>(), c = 0
      for (let i of this._items) {
        r.append(i), c++
        if (c == amount) break
      }
      return r
    }

    /**
     * Skip "amount" items and get the rest
     *
     * @param {number} amount
     * @returns
     * @memberof collection
     */
    public skip(amount: number) {
      let r = new collection<T>(), c = 0
      for (let i of this._items) {
        if (c < amount) { c++; continue }
        r.append(i), c++
      }
      return r
    }

    /**
     * Take items while they pass the truth test
     *
     * @param {(value, index) => boolean} callback
     * @returns
     * @memberof collection
     */
    public takeWhile(callback: (value, index) => boolean) {
      let r = new collection<T>()
      for (let i = 0, l = this._items.length; i < l; i++) {
        let item = this.index(i)
        if (callback(item, i)) {
          r.append(item)
        }
      }
      return r
    }

    /**
     * Take items while they fail the truth test
     *
     * @param {(value, index) => boolean} callback
     * @returns
     * @memberof collection
     */
    public skipWhile(callback: (value, index) => boolean) {
      let r = new collection<T>()
      for (let i = 0, l = this._items.length; i < l; i++) {
        let item = this.index(i)
        if (!callback(item, i)) {
          r.append(item)
        }
      }
      return r
    }

    /**
     * Zips two collections together bassed on a callback
     *
     * @param {collection<any>} items
     * @param {(first, second) => any} callback
     * @returns
     * @memberof collection
     */
    public zip(items: collection<any>, callback: (first, second) => any) {
      let length = items.length > this._items.length ? items.length : this._items.length
      let r = new collection<any>()
      for (let i = 0; i < length; i++) {
        r.append(callback(this.index(i), items.index(i)))
      }
      return r
    }

    /**
     * Gets the average of the items in the collection
     *
     * @param {string} [key]
     * @returns
     * @memberof collection
     */
    public average(key?: string) {
      let c = 0, t = 0
      if (!key) {
        this._items.forEach(n => { typeof n == 'number' ? t += n : null, c++ })
      } else {
        this._items.forEach(o => { if (o[key]) { t += o[key], c++ } })
      }
      return t / c
    }

    /**
     * Gets the min value of the items in the collection
     *
     * @param {string} [key]
     * @returns
     * @memberof collection
     */
    public min(key?: string) {
      let min = null
      if (!key) {
        this._items.forEach(n => min = (!min || n < min) ? n : min)
      } else {
        this._items.forEach(o => { if (o[key]) { min = !min || o[key] < min ? o[key] : min } })
      }
      return min
    }

    /**
     * Gets the max value of the items in the collection
     *
     * @param {string} [key]
     * @returns
     * @memberof collection
     */
    public max(key?: string) {
      let max = 0
      if (!key) {
        this._items.forEach(n => max = <number>((!max || (typeof n == 'number' && n > max)) ? n : max))
      } else {
        this._items.forEach(o => { if (o[key]) { max = !max || o[key] > max ? o[key] : max } })
      }
      return max
    }
  }
}